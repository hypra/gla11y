#!/usr/bin/env python
#
# Copyright (c) 2018 Martin Pieuchot
# Copyright (c) 2018 Samuel Thibault <sthibault@hypra.fr>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# Take LibreOffice (glade) .ui files and check for non accessible widgets

from __future__ import print_function

import os
import sys
import getopt
try:
    import lxml.etree as ET
    lxml = True
except ImportError:
    if sys.version_info < (2,7):
        print("gla11y needs lxml or python >= 2.7")
        exit()
    import xml.etree.ElementTree as ET
    lxml = False


widgets_ignored = [
    # Containers
    'GtkFrame',
    'GtkWindow',
    'GtkScrolledWindow',
    'GtkDialog',
    'GtkMessageDialog',
    'GtkNotebook',

    # Invisible actions
    'GtkAlignment',
    'GtkAdjustment',
    'GtkBox',
    'GtkVBox',
    'GtkHBox',
    'GtkButtonBox',
    'GtkGrid',
    'GtkSizeGroup',
    'GtkSeparator',
    'GtkExpander',
    'GtkActionGroup',
    'GtkViewport',
    'GtkPaned',
    'GtkCellRendererText',

    'sfxlo-PriorityHBox',
    'sfxlo-PriorityMergedHBox',
    'sfxlo-ContextVBox',

    'GtkScrollbar',
    'GtkListBox',
    'GtkStatusbar',

    # Storage objects
    'GtkListStore',
    'GtkTextBuffer',
    'GtkTreeSelection',

    'svtlo-ValueSet',

    # These are actually labels
    'GtkLinkButton',

    # Menus are fine
    'GtkMenu',
    'GtkMenuItem',
    'GtkRadioMenuItem',
    'GtkSeparatorMenuItem',
    'GtkCheckMenuItem',

    # Toolbars are fine
    # FIXME: err, they need an action name
    'GtkToolbar',
    'GtkSeparatorToolItem',
    'GtkToggleToolButton',
    'GtkRadioToolButton',
    'GtkMenuToolButton',
    'GtkToolButton',
    'GtkToolItem',

    'sfxlo-NotebookbarToolBox',
    'sfxlo-SidebarToolBox',
    'svtlo-ManagedMenuButton',
    'vcllo-SmallButton',
    'sfxlo-NotebookbarTabControl',
    'sfxlo-DropdownBox',
    'sfxlo-OptionalBox',

    'vcllo-PrintPreviewWindow',
    'cuilo-SvxNumberPreview',
    'cuilo-BackgroundPreview',

    'AtkObject',
]

# These widgets always need a label
widgets_needlabel = [
    'GtkEntry',
    'GtkScale',
    'GtkSpinButton',
    'GtkSwitch',
]

# These widgets normally have their own label
widgets_buttons = [
    'GtkButton',
    'GtkToggleButton',
    'GtkToolButton',
    'GtkRadioButton',
    'GtkCheckButton',
    'GtkLockButton',
]

# To include for LO for sure:
# svxcorelo-SvxColorListBox
# svxcorelo-SvxLanguageBox comme ComboBox
# foruilo-RefButton
# sfxlo-SvxCharView
# foruilo-RefEdit
# svxcorelo-PaperSizeListBox comme combobox
# mettre tous les svxcorelo?

# svtlo-SvSimpleTableContainer ?

# svxcorelo-SvxCheckListBox ?
# svtlo-SvTreeListBox ?

progname = os.path.basename(sys.argv[0])
suppressions = {}
ids = {}
ids_dup = {}
labelled_by_elm = {}
label_for_elm = {}
mnemonic_for_elm = {}
gen_suppr = None
gen_supprfile = None
suppr_prefix = ""
outfile = None
pflag = False
Werror = False
Wnone = False
errors = 0
errexists = 0
warnings = 0
warnexists = 0

def elm_parent(root, elm):
    """
    Return the parent of the element.
    """
    if lxml:
        return elm.getparent()
    else:
        def find_parent(cur, elm):
            for o in cur:
                if o == elm:
                    return cur
                parent = find_parent(o, elm)
                if parent is not None:
                    return parent
            return None
        return find_parent(root, elm)

def is_labelled_parent(elm):
    """
    Return whether this element is a labelled parent
    """
    klass = elm.attrib.get('class')
    if klass == 'GtkDialog':
        return True
    if klass == 'GtkFrame' or klass == 'GtkNotebook':
        children = elm.findall("child[@type='tab']") + elm.findall("child[@type='label']") 
        if len(children) >= 1:
            return True
    return False

def elm_labelled_parent(root, elm):
    """
    Return the first labelled parent of the element, which can thus be used as
    the root of widgets with common labelled context
    """

    if lxml:
        def find_labelled_parent(elm):
            if is_labelled_parent(elm):
                return elm
            parent = elm.getparent()
            if parent is None:
                return None
            return find_labelled_parent(parent)
        parent = elm.getparent()
        if parent is None:
            return None
        return find_labelled_parent(elm.getparent())
    else:
        def find_labelled_parent(cur, elm):
            if cur == elm:
                # the target element is over there
                return True
            for o in cur:
                parent = find_labelled_parent(o, elm)
                if parent == True:
                    # target element is over there, check ourself
                    if is_labelled_parent(cur):
                        # yes, and we are the first ancestor of the target element
                        return cur
                    else:
                        # no, but target element is over there.
                        return True
                if parent != None:
                    # the first ancestor of the target element was over there
                    return parent
            return None
        parent = find_labelled_parent(root, elm)
        if parent == True:
            parent = None
        return parent

def is_orphaned_label(filename, tree, root, obj, doprint = False):
    """
    Check whether this label has no accessibility relation, or doubtful relation
    because another label labels the same target
    """
    global label_for_elm, labelled_by_elm, mnemonic_for_elm

    # This is not a label for something, ignore it.
    # TODO: standard way instead of no-label-for?
    no_label_for = obj.findall("accessibility/relation[@type='no-label-for']")
    if len(no_label_for) > 0:
        return False

    # label-for
    label_for = obj.findall("accessibility/relation[@type='label-for']")
    for rel in label_for:
        target = rel.attrib['target']
        l = label_for_elm[target]
        if len(l) > 1:
            # Several labels label the same target, consider us as orphaned.
            #if doprint:
            #    if target in ids:
            #        widget = elm_name_line(ids[target])
            #    else:
            #        widget = target
            #    warn(filename, tree, obj, "duplicate-label-for", "targets with label-for the same widget " + widget + "as other labels " + elms_names_lines(l))
            return True

    # mnemonic_widget
    mnemonic_for = obj.findall("property[@name='mnemonic_widget']")
    for rel in mnemonic_for:
        target = rel.text
        l = mnemonic_for_elm[target]
        if len(l) > 1:
            # Several labels are mnemonics for the same target, consider us as orphaned.
            #if doprint:
            #    if target in ids:
            #        widget = elm_name_line(ids[target])
            #    else:
            #        widget = target
            #    warn(filename, tree, obj, "duplicate-mnemonic", "targets with mnemonic_widget the same widget " + widget + "as other labels " + elms_names_lines(l))
            return True

    if len(label_for) > 0:
        # At least one label-for, we are not orphaned.
        return False

    if len(mnemonic_for) > 0:
        # At least one mnemonic_widget, we are not orphaned.
        return False

    labelled_by = obj.findall("accessibility/relation[@type='labelled-by']")
    if len(labelled_by) > 0:
        # Oh, a labelled label, probably not to be labelling anything
        return False

    parent = elm_parent(root, obj)
    if parent is not None:
        childtype = parent.attrib.get('type')
        if parent.tag == 'child' and childtype == 'label' \
                                  or childtype == 'tab':
            # This is a frame or a notebook label, not orphaned.
            return False

    oid = obj.attrib.get('oid')
    if oid is not None:
        if oid in labelled_by_elm:
            # Some widget is labelled by us, we are not orphaned.
            # We should have had a label-for, will warn about it later.
            return False

    # No label-for, no mnemonic-for, no labelled-by, we are orphaned.
    if doprint:
        warn(filename, tree, obj, "orphan-label", "does not specify what it labels")
    return True

def orphaned_labels(filename, tree, root, elm):
    """
    Check whether from some element there exists an orphaned label
    """
    if elm.attrib.get('class') == 'GtkLabel' and \
        is_orphaned_label(filename, tree, root, elm):
        return True
    for obj in elm:
        # We are not interested in orphaned labels under another labelled
        # parent.  This also allows to keep linear complexity.
        if not is_labelled_parent(obj):
            if orphaned_labels(filename, tree, root, obj):
                return True
    return False

def step_elm(elm):
    """
    Return the XML class path step corresponding to elm.
    This can be empty if the elm does not have any class or id.
    """
    step = elm.attrib.get('class')
    if step is None:
        step = ""
    oid = elm.attrib.get('id')
    if oid is not None:
        oid = oid.encode('ascii','ignore').decode('ascii')
        step += "[@id='%s']" % oid
    if len(step) > 0:
        step += '/'
    return step

def find_elm(root, elm):
    """
    Return the XML class path of the element from the given root.
    This is the slow version used when getparent is not available.
    """
    if root == elm:
        return ""
    for o in root:
        path = find_elm(o, elm)
        if path is not None:
            step = step_elm(o)
            return step + path
    return None

def errpath(filename, tree, elm):
    """
    Return the XML class path of the element
    """
    if elm is None:
        return ""
    path = ""
    if 'class' in elm.attrib:
        path += elm.attrib['class']
    oid = elm.attrib.get('id')
    if oid is not None:
        oid = oid.encode('ascii','ignore').decode('ascii')
        path += "[@id='%s']" % oid
    if lxml:
        elm = elm.getparent()
        while elm is not None:
            step = step_elm(elm)
            path = step + path
            elm = elm.getparent()
    else:
        path = find_elm(tree.getroot(), elm)[:-1]
    path = filename + ':' + path
    return path

def elm_prefix(filename, elm):
    """
    Return the display prefix of the element
    """
    if elm == None or not lxml:
        return "%s:" % filename
    else:
        return "%s:%u" % (filename, elm.sourceline)

def elm_name(elm):
    """
    Return a display name of the element
    """
    if elm is not None:
        name = ""
        if 'class' in elm.attrib:
            name = "'%s' " % elm.attrib['class']
        if 'id' in elm.attrib:
            id = elm.attrib['id'].encode('ascii','ignore').decode('ascii')
            name += "'%s' " % id
        if not name:
            name = "'" + elm.tag + "'"
            if lxml:
                name += " line " + str(elm.sourceline)
        return name
    return ""

def elm_name_line(elm):
    """
    Return a display name of the element with line number
    """
    if elm is not None:
        name = elm_name(elm)
        if lxml and " line " not in name:
            name += "line " + str(elm.sourceline) + " "
        return name
    return ""

def elm_suppr(filename, tree, elm, msgtype):
    """
    Return the prefix to be displayed to the user and the suppression line for
    the warning type "msgtype" for element "elm"
    """
    global gen_suppr, gen_supprfile, suppr_prefix, pflag

    if suppressions or gen_suppr is not None or pflag:
        prefix = errpath(filename, tree, elm)
        if prefix[0:len(suppr_prefix)] == suppr_prefix:
            prefix = prefix[len(suppr_prefix):]

    if suppressions or gen_suppr is not None:
        suppr = '%s %s' % (prefix, msgtype)

        if gen_suppr is not None and msgtype is not None:
            if gen_supprfile is None:
                gen_supprfile = open(gen_suppr, 'w')
            print(suppr, file=gen_supprfile)
    else:
        suppr = None

    if not pflag:
        # Use user-friendly line numbers
        prefix = elm_prefix(filename, elm)
        if prefix[0:len(suppr_prefix)] == suppr_prefix:
            prefix = prefix[len(suppr_prefix):]

    return (prefix, suppr)

def err(filename, tree, elm, msgtype, msg):
    """
    Emit an error for an element
    """
    global errors, errexists

    (prefix, suppr) = elm_suppr(filename, tree, elm, msgtype)

    if suppr in suppressions:
        # Suppressed
        errexists += 1
        return

    errors += 1
    msg = "%s ERROR: %s%s" % (prefix, elm_name(elm), msg)
    print(msg)
    if outfile is not None:
        print(msg, file=outfile)


def warn(filename, tree, elm, msgtype, msg):
    """
    Emit a warning for an element
    """
    global Werror, Wnone, errors, errexists, warnings, warnexists

    if Wnone:
        return

    (prefix, suppr) = elm_suppr(filename, tree, elm, msgtype)
    if suppr in suppressions:
        # Suppressed
        if Werror:
            errexists += 1
        else:
            warnexists += 1
        return

    if Werror:
        errors += 1
    else:
        warnings += 1

    msg = "%s WARNING: %s%s" % (prefix, elm_name(elm), msg)
    print(msg)
    if outfile is not None:
        print(msg, file=outfile)


def check_props(filename, tree, root, elm, forward):
    """
    Check the given list of relation properties
    """
    props = elm.findall("property[@name='mnemonic_widget']")
    for prop in props:
        if prop.text not in ids:
            err(filename, tree, elm, "undeclared-target", forward + " uses undeclared target '%s'" % prop.text)
    return props

def check_rels(filename, tree, root, elm, forward, backward = None):
    """
    Check the relations given by forward
    """
    oid = elm.attrib.get('id')
    rels = elm.findall("accessibility/relation[@type='" + forward + "']")
    for rel in rels:
        target = rel.attrib['target']
        if target not in ids:
            err(filename, tree, elm, "undeclared-target", forward + " uses undeclared target '%s'" % target)
        elif backward is not None:
            widget = ids[target]
            backrels = widget.findall("accessibility/relation[@type='" + backward + "']")
            if len([x for x in backrels if x.attrib['target'] == oid]) == 0:
                warn(filename, tree, elm, "missing-" + backward, "has " + forward + \
                     ", but is not " + backward + " by " + elm_name_line(widget))
    return rels

def elm_line(elm):
    """
    Return the line for the given element.
    """
    if lxml:
        return " line " + str(elm.sourceline)
    else:
        return ""

def elms_lines(elms):
    """
    Return the list of lines for the given elements.
    """
    if lxml:
        return " lines " + ', '.join([str(l.sourceline) for l in elms])
    else:
        return ""

def elms_names_lines(elms):
    """
    Return the list of names and lines for the given elements.
    """
    return ', '.join([elm_name_line(elm) for elm in elms])

def check_a11y_relation(filename, tree):
    """
    Emit an error message if any of the 'object' elements of the XML
    document represented by `root' doesn't comply with Accessibility
    rules.
    """
    global widgets_ignored, ids, label_for_elm, labelled_by_elm, mnemonic_for_elm

    def check_elm(orphan_root, obj, orphaned):
        """
        Check one element, knowing that orphaned tells whether there are
        orphaned labels within orphan_root
        """

        oid = obj.attrib.get('id')
        klass = obj.attrib.get('class')

        # "Don't care" special case
        if klass in widgets_ignored:
            return

        # Widgets usual do not strictly require a label, i.e. a labelled parent
        # is enough for context, but some do always need one.
        requires_label = klass in widgets_needlabel

        if oid is not None:
            # Check that ids are unique
            if oid in ids_dup:
                if ids[oid] == obj:
                    # We are the first, warn
                    duplicates = tree.findall(".//object[@id='" + oid + "']")
                    warn(filename, tree, obj, "duplicate-id", "has the same id as other elements " + elms_names_lines(duplicates))

        # Check label-for and their dual labelled-by
        label_for = check_rels(filename, tree, root, obj, "label-for", "labelled-by")

        # Check labelled-by and its dual label-for
        labelled_by = check_rels(filename, tree, root, obj, "labelled-by", "label-for")

        # Should have only one label
        if len(labelled_by) >= 1:
            if oid in mnemonic_for_elm:
                err(filename, tree, obj, "labelled-by-and-mnemonic",
                    "has both a mnemonic " + elm_name_line(mnemonic_for_elm[oid][0]) + "and labelled-by relation")
            if len(labelled_by) > 1:
                err(filename, tree, obj, "multiple-labelled-by", "has multiple labelled-by relations")
        if oid in label_for_elm:
            if len(label_for_elm[oid]) > 1:
                warn(filename, tree, obj, "duplicate-label-for", "is referenced by multiple label-for " + elms_names_lines(label_for_elm[oid]))
        if oid in mnemonic_for_elm:
            if len(mnemonic_for_elm[oid]) > 1:
                warn(filename, tree, obj, "duplicate-label-for", "is referenced by multiple mnemonic_widget " + elms_names_lines(mnemonic_for_elm[oid]))

        # Check member-of
        member_of = check_rels(filename, tree, root, obj, "member-of")


        # GtkLabel special case
        if klass == 'GtkLabel':
            properties = check_props(filename, tree, root, obj, "mnemonic_widget")
            if len(properties) > 1:
                err(filename, tree, obj, "multiple-mnemonic", "has multiple mnemonic_widgets properties"
                    "%s" % elms_lines(properties))

            # Emit orphaning warnings
            is_orphaned_label(filename, tree, root, obj, True)

            # We are done with the label
            return


        # Not a label, will perhaps need one

        # Case 1: has an explicit <child internal-child="accessible"> sub-element
        children = obj.findall("child[@internal-child='accessible']")
        if len(children) > 1:
            err(filename, tree, obj, "multiple-accessible", "has multiple <child internal-child='accessible'>"
                "%s" % elms_lines(children))
        if len(children) >= 1:
            return

        # Case 2: has an <accessibility> sub-element with a "labelled-by"
        # <relation> pointing to an existing element.
        if len(labelled_by) > 0:
            return

        # Case 3: has a label-for
        if oid in label_for_elm:
            return

        # Case 4: has a mnemonic
        if oid in mnemonic_for_elm:
            return

        # Case 5: Has a <property name="tooltip_text">
        tooltips = obj.findall("property[@name='tooltip_text']")
        if len(tooltips) > 1:
            err(filename, tree, obj, "multiple-tooltip", "has multiple tooltip_text properties")
        if len(tooltips) >= 1:
            return

        # Case 6: Has a <property name="placeholder_text">
        placeholders = obj.findall("property[@name='placeholder_text']")
        if len(placeholders) > 1:
            err(filename, tree, obj, "multiple-placeholder", "has multiple placeholder_text properties")
        if len(placeholders) >= 1:
            return

        # Buttons usually don't need an external label, their own is enough, (but they do need one)
        if klass in widgets_buttons:

            labels = obj.findall("property[@name='label']")
            if len(labels) > 1:
                err(filename, tree, obj, "multiple-label", "has multiple label properties")
            if len(labels) >= 1:
                # Has a <property name="label">
                return

            actions = obj.findall("property[@name='action_name']")
            if len(actions) > 1:
                err(filename, tree, obj, "multiple-action_name", "has multiple action_name properties")
            if len(actions) >= 1:
                # Has a <property name="action_name">
                return

            # no label for a button, warn
            warn(filename, tree, obj, "button-no-label", "does not have its own label");
            return

        # GtkImages special case
        if klass == "GtkImage":
            uses = [u for u in tree.iterfind(".//object/property[@name='image']") if u.text == oid]
            if len(uses) > 0:
                # This image is just used by another element, don't warn
                # about the image itself, we probably want the warning on
                # the element instead.
                return

        # GtkEntry special case
        if klass == 'GtkEntry':
            parent = elm_parent(root, obj)
            if parent is not None:
                if parent.tag == 'child' and \
                    parent.attrib.get('internal-child') == "entry":
                    # This is an internal entry of another widget. Relations
                    # will be handled by that widget.
                    return


        # Really no label, perhaps emit a warning

        if not orphaned:
            # No orphaned label, so probably the labelled parent provides enough
            # context.
            if requires_label:
                # But these always need a label.
                warn(filename, tree, obj, "no-labelled-by", "has no accessibility label")
            return

        context = elm_name(orphan_root)
        if context:
            context = " within " + context
        warn(filename, tree, obj, "no-labelled-by", "has no accessibility label while there are orphaned labels" + context)
        return

    root = tree.getroot()

    # Flush ids and relations from previous files
    ids = {}
    ids_dup = {}
    labelled_by_elm = {}
    label_for_elm = {}
    mnemonic_for_elm = {}

    # First pass to get links into hash tables, no warning, just record duplicates
    for obj in root.iter('object'):
        oid = obj.attrib.get('id')
        if oid is not None:
            if oid not in ids:
                ids[oid] = obj
            else:
                ids_dup[oid] = True

        labelled_by = obj.findall("accessibility/relation[@type='labelled-by']")
        for rel in labelled_by:
            target = rel.attrib.get('target')
            if target is not None:
                if target not in labelled_by_elm:
                    labelled_by_elm[target] = [ obj ]
                else:
                    labelled_by_elm[target].append(obj)

        label_for = obj.findall("accessibility/relation[@type='label-for']")
        for rel in label_for:
            target = rel.attrib.get('target')
            if target is not None:
                if target not in label_for_elm:
                    label_for_elm[target] = [ obj ]
                else:
                    label_for_elm[target].append(obj)

        mnemonic_for = obj.findall("property[@name='mnemonic_widget']")
        for rel in mnemonic_for:
            target = rel.text
            if target is not None:
                if target not in mnemonic_for_elm:
                    mnemonic_for_elm[target] = [ obj ]
                else:
                    mnemonic_for_elm[target].append(obj)

    # Second pass, recursive depth-first, to be able to efficiently know whether
    # there are orphaned labels within a part of the tree.
    def recurse(orphan_root, obj, orphaned):
        if obj == root or is_labelled_parent(obj):
            orphan_root = obj
            orphaned = orphaned_labels(filename, tree, root, obj)

        if obj.tag == 'object':
            check_elm(orphan_root, obj, orphaned)

        for o in obj:
            recurse(orphan_root, o, orphaned)

    recurse(root, root, False)

def usage():
    print("%s [-W error|none] [-p] [-g SUPPR_FILE] [-s SUPPR_FILE] [-i WIDGET1,WIDGET2[,...]] [-o LOG_FILE] [file ...]" % progname,
          file=sys.stderr)
    print("  -p print XML class path instead of line number");
    print("  -g Generate suppression file SUPPR_FILE");
    print("  -s Suppress warnings given by file SUPPR_FILE");
    print("  -i Ignore warnings for widgets of a given class");
    print("  -o Also prints errors and warnings to given file");
    sys.exit(2)


def main():
    global pflag, Werror, Wnone, gen_suppr, gen_supprfile, suppressions, suppr_prefix, errors, widgets_ignored, outfile

    try:
        opts, args = getopt.getopt(sys.argv[1:], "W:piIg:s:P:o:L:")
    except getopt.GetoptError:
        usage()

    suppr = None
    out = None
    filelist = None
    ignore = False
    widgets = []

    for o, a in opts:
        if o == "-W":
            if a == "error":
                Werror = True
            elif a == "none":
                Wnone = True
        elif o == "-p":
            pflag = True
        elif o == "-i":
            widgets = a.split(',')
        elif o == "-I":
            ignore = True
        elif o == "-g":
            gen_suppr = a
        elif o == "-s":
            suppr = a
        elif o == "-P":
            suppr_prefix = a
        elif o == "-o":
            out = a
        elif o == "-L":
            filelist = a

    if ignore and widgets:
        usage()

    if ignore:
        widgets_ignored = []
    elif widgets:
        widgets_ignored.extend(widgets)

    # Read suppression file before overwriting it
    if suppr is not None:
        try:
            supprfile = open(suppr, 'r')
            for line in supprfile.readlines():
                prefix = line.rstrip()
                suppressions[prefix] = True
            supprfile.close()
        except IOError:
            pass

    if out is not None:
        outfile = open(out, 'w')

    if filelist is not None:
        try:
            filelistfile = open(filelist, 'r')
            for line in filelistfile.readlines():
                line = line.strip()
                if line:
                    args += line.split(' ')
            filelistfile.close()
        except IOError:
            err(filelist, None, None, "unable to read file list file")

    for filename in args:
        try:
            tree = ET.parse(filename)
        except ET.ParseError:
            err(filename, None, None, "parse", "malformatted xml file")
            continue
        except IOError:
            err(filename, None, None, None, "unable to read file")
            continue

        try:
            check_a11y_relation(filename, tree)
        except Exception as error:
            import traceback
            traceback.print_exc()
            err(filename, None, None, "parse", "error parsing file")

    if errors > 0 or errexists > 0:
        estr = "%s new error%s" % (errors, 's' if errors > 1 else '')
        if errexists > 0:
            estr += " (%s suppressed by %s)" % (errexists, suppr)
        print(estr)

    if warnings > 0 or warnexists > 0:
        wstr = "%s new warning%s" % (warnings,
                                           's' if warnings > 1 else '')
        if warnexists > 0:
            wstr += " (%s suppressed by %s)" % (warnexists, suppr)
        print(wstr)

    if gen_supprfile is not None:
        gen_supprfile.close()
    if outfile is not None:
        outfile.close()
    if errors > 0 and gen_suppr is None:
        sys.exit(1)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass

# vim: set shiftwidth=4 softtabstop=4 expandtab:
